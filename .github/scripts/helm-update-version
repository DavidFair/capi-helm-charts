#!/usr/bin/env python3

import argparse
import json
import os

import requests
import yaml

import easysemver


parser = argparse.ArgumentParser(
    description = "Updates a dependency key to the latest version of a Helm chart."
)
parser.add_argument(
    "--dependencies-file",
    default = "./dependencies.json",
    help = "The path of the file containing the dependencies."
)
parser.add_argument("repo_url", help = "The URL of the Helm repo.")
parser.add_argument("chart_name", help = "The name of the chart.")
parser.add_argument("key", help = "The key to update with the new version.")
parser.add_argument(
    "constraints",
    help = "Comma-separated list of constraints to apply when considering versions."
)
args = parser.parse_args()


with open(args.dependencies_file) as fh:
    data = json.load(fh)

# Pull down the list of versions for the chart
response = requests.get(f"{args.repo_url}/index.yaml")
response.raise_for_status()
entries = yaml.safe_load(response.text)["entries"][args.chart_name]

# Find the most recent version that matches the constraints
version_range = easysemver.Range(args.constraints)
next_version = None
for entry in entries:
    try:
        version = easysemver.Version(entry["version"])
    except TypeError:
        continue
    if version not in version_range:
        continue
    if next_version is None or version > next_version:
        next_version = version

# Update the version variable
if next_version:
    data[args.key] = str(next_version)

with open(args.dependencies_file, "w") as fh:
    json.dump(data, fh, indent = 4)

# Output the next version so it can be consumed by later steps
output_path = os.environ.get("GITHUB_OUTPUT", "/dev/stdout")
with open(output_path, "a") as fh:
    print(f"next-version={next_version}", file = fh)
